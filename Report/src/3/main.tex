\chapter{Reflections}
This chapter is used for reflecting upon differenct aspects of the object oriented paradigm, aswell as dynamic typing and the actor paradigm.

\section{Object Oriented Programming --- Something I used to know}
My first experience in the object oriented part of the PP course, was getting told that what I knew as object oriented programming, was a lie.
That is to say, what I had been taught was a watered down version, with mixins from numerous other paradigms.
Initially, I put off the accusation, partly due to the face that I have completed a course called \enquote{Object Oriented Programming}.
But as the lecture in \enquote{true} OOP carried on, I quickly realized that the object oriented purity of Smalltalk was unmatched by any programming language I had ever seen.

\bigskip
After having completed the first mini--project, and hereby implemented a calendar in a purely functional programming language,
I found the outlook of using a object oriented language to do the same implentation rather comforting.
Although working in the functional paradigm had proven to be quite plessant and more important very powerfull,
the implementation details of a calendar seemed to fit better with the way of modelling in object oriented languages.

\bigskip
Moreover the notion of mutability, and variables was something I missed in the functional paradigm, as these concepts are key parts of most programming I regulary use.
These are multi--paradigm programming languages such as Python, Java, C\#, and JavaScript.
They all borrow from both the functional and the object oriented paradigm, and thus enbodies the best of both worlds --- or ruins the pure experience as some might state.

\bigskip
As with programming in the functional paradigm and specificly Scheme, Smalltalk does not have special syntax for thing like control structures.
In fact the syntax of Smalltalk is extremely simple and therefore needs the environment around it, in my case Pharo, to be powerfull.

\section{Dynamic versus Static Typing}
In my book, choosing the right tool for the job, is not something that only applies to programming paradigm but also type typing.
Some problems require static typing to be developed and/or maintained correctly, while other bennifit greatly from the freedom of dynamic type systems.

For instance, programming languages with dynamic typing are often supiriour when it comes to prototyping, and makes it easier to dive right in --- at least in my experience.
However, tooling for programming languages with dynamic typing often fall short when compared to that of staticly typed languages.
Take for example Intellisense, a great tool that only exists, because of the type system in place in C\#, which can infer and predict certain things about the system.

\bigskip
When dealing with larger projects and the systems thereof, especially those with a lot of people working on them,
using dynamic typing can influence the robustness and development negatively, since you loose the type security.

Static typing can give some guarentees, which otherwise must be reached with testing and checking done by the programmer, this can be cumbersome and is error prone.
Moreover, staticly typed languages can catch some errors at compile time, and even do code analysis and optimizations, which just not are possible in dynamicly typed languages.

\bigskip
Personally, I think that the benefits of dynamically typed languages are greater than the cons.
The turn--around--time of code and flexibility is in my opinion unmatched by statically typed languages.

As long as the programmer utilises duck typing, dynamically typed languages can be incredibelly powerful.
Moreover, the ability to easily do dynamic dispatch as I did with the \texttt{flattenTo: aList} method, which both Appointments and Calendars have,
is extremely easy and powerful; and the implicitness of interfaces reduces the amount of boilerplate code which can be very cumbersome to write.
Basically, as long as some object understands a specific message, I do not care about what \enquote{type} it is.

\section{Modern Languages}
In the first mini--project I used Scheme, which was created in the 1970s, as was Smalltalk which I used in this mini--project.
How could using a modern language have benefitted my solutions?
Well, I believe that the final product would not have differed much, at least in functionality.

The thing with choosing a modern language is that often you end up with a less mature language, or a language that tries to innovate on something that works just fine in older languages.
A common trait for both Scheme and Smalltalk, is the simplicity of the syntax, however, using their simple syntax one can implement the solutions of the calendar exercise just fine.
Nevertheless I do believe that some features of the more modern programming languages, and the fact that often the communities around them are more active, could be a pro when using them.

\section{The Actor Paradigm}
Taking the implementation to an entirely new paradigm, what might have differed in the actor paradigm?
Allthough the Smalltalk objects closely match what an actor is, the pure actor paradigm would bring better ability to do computations concurrently.
The alternative name for the actor paradigm is the concurrency paradigm, and I do not doubt that the computational model of the actor paradigm, is significantly better at utilizing multicore systems.

Even thought most programming languages have things as threads and multi--processing, they also have locks, and mutexes;
and more often than not multi--core utilization is a hindrence to both the development process and execution of code.

However, since messges in the actor paradigm are received asynchronosly, one must be careful and ensure synchronization in cases where it is nessecary.
Take for example a banking account; if one actor representing the banking account with a balance of 2 dollars,
and two seperate actors does a deposit of 4 dollars and a withdrawel of 5 dollars respectively,
one can not guarentee that the 4 dollars are deposited before the withdrawel of 5 dollars is tried.

That being said, certain guarentees can be made --- e.g. we can guarentee that one action will always complete before starting the next,
which means that the worst case scenario in the example above is that the withdrawel is declined.
